import { clone, filter } from '../rdfjs.mjs';
import { isNamedNode, isLiteral, xmlSchemaTypes, deserializeInteger, deserializeDecimal, deserializeDatetime, deserializeBoolean, isLocalNode, asNamedNode } from '../datatypes.mjs';
import { hasChangelog } from '../interfaces.mjs';
import { isThingLocal, asUrl, isThing, ThingExpectedError } from './thing.mjs';
import { internal_cloneResource } from '../resource/resource.internal.mjs';

/**
 * Copyright 2020 Inrupt Inc.
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal in
 * the Software without restriction, including without limitation the rights to use,
 * copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the
 * Software, and to permit persons to whom the Software is furnished to do so,
 * subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED,
 * INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A
 * PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT
 * HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
 * OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE
 * SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
 */
/** @hidden For internal use only. */
function internal_getReadableValue(value) {
    var _a, _b, _c, _d, _e, _f, _g, _h;
    if (isNamedNode(value)) {
        return `<${value.value}> (URL)`;
    }
    if (isLiteral(value)) {
        if (!isNamedNode(value.datatype)) {
            return `[${value.value}] (RDF/JS Literal of unknown type)`;
        }
        let val;
        switch (value.datatype.value) {
            case xmlSchemaTypes.boolean:
                val =
                    (_b = (_a = deserializeBoolean(value.value)) === null || _a === void 0 ? void 0 : _a.valueOf()) !== null && _b !== void 0 ? _b : `Invalid data: \`${value.value}\``;
                return val + " (boolean)";
            case xmlSchemaTypes.dateTime:
                val =
                    (_d = (_c = deserializeDatetime(value.value)) === null || _c === void 0 ? void 0 : _c.toUTCString()) !== null && _d !== void 0 ? _d : `Invalid data: \`${value.value}\``;
                return val + " (datetime)";
            case xmlSchemaTypes.decimal:
                val =
                    (_f = (_e = deserializeDecimal(value.value)) === null || _e === void 0 ? void 0 : _e.toString()) !== null && _f !== void 0 ? _f : `Invalid data: \`${value.value}\``;
                return val + " (decimal)";
            case xmlSchemaTypes.integer:
                val =
                    (_h = (_g = deserializeInteger(value.value)) === null || _g === void 0 ? void 0 : _g.toString()) !== null && _h !== void 0 ? _h : `Invalid data: \`${value.value}\``;
                return val + " (integer)";
            case xmlSchemaTypes.langString:
                return `"${value.value}" (${value.language} string)`;
            case xmlSchemaTypes.string:
                return `"${value.value}" (string)`;
            default:
                return `[${value.value}] (RDF/JS Literal of type: \`${value.datatype.value}\`)`;
        }
    }
    if (isLocalNode(value)) {
        return `<#${value.internal_name}> (URL)`;
    }
    if (value.termType === "BlankNode") {
        return `[${value.value}] (RDF/JS BlankNode)`;
    }
    if (value.termType === "Quad") {
        return `??? (nested RDF* Quad)`;
    }
    /* istanbul ignore else: The if statements are exhaustive; if not, TypeScript will complain. */
    if (value.termType === "Variable") {
        return `?${value.value} (RDF/JS Variable)`;
    }
    /* istanbul ignore next: The if statements are exhaustive; if not, TypeScript will complain. */
    return value;
}
/** @hidden */
function internal_toNode(thing) {
    if (isNamedNode(thing) || isLocalNode(thing)) {
        return thing;
    }
    if (typeof thing === "string") {
        return asNamedNode(thing);
    }
    if (isThingLocal(thing)) {
        return thing.internal_localSubject;
    }
    return asNamedNode(asUrl(thing));
}
/**
 * @internal
 * @param thing Thing to clone.
 * @returns A new Thing with the same Quads as `input`.
 */
function internal_cloneThing(thing) {
    const cloned = clone(thing);
    if (isThingLocal(thing)) {
        cloned.internal_localSubject = thing.internal_localSubject;
        return cloned;
    }
    cloned.internal_url = thing.internal_url;
    return cloned;
}
/**
 * @internal
 * @param thing Thing to clone.
 * @param callback Function that takes a Quad, and returns a boolean indicating whether that Quad should be included in the cloned Dataset.
 * @returns A new Thing with the same Quads as `input`, excluding the ones for which `callback` returned `false`.
 */
function internal_filterThing(thing, callback) {
    const filtered = filter(thing, callback);
    if (isThingLocal(thing)) {
        filtered.internal_localSubject =
            thing.internal_localSubject;
        return filtered;
    }
    filtered.internal_url = thing.internal_url;
    return filtered;
}
/**
 * @hidden
 */
function internal_throwIfNotThing(thing) {
    if (!isThing(thing)) {
        throw new ThingExpectedError(thing);
    }
}
/**
 * Enforces the presence of a Changelog for a given dataset. If a changelog is
 * already present, it is unchanged. Otherwise, an empty changelog is created.
 * @hidden
 * @param solidDataset
 */
function internal_withChangeLog(solidDataset) {
    const newSolidDataset = hasChangelog(solidDataset)
        ? solidDataset
        : Object.assign(internal_cloneResource(solidDataset), {
            internal_changeLog: { additions: [], deletions: [] },
        });
    return newSolidDataset;
}

export { internal_cloneThing, internal_filterThing, internal_getReadableValue, internal_throwIfNotThing, internal_toNode, internal_withChangeLog };
